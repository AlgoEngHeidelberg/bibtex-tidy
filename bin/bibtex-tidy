#!/usr/bin/env node
/* jshint node: true, esversion: 6 */
'use strict';

const tidy = require('../bibtex-tidy.js');
const fs = require('fs');
const path = require('path');
const argv = require('yargs')
	.usage('Usage: $0 <file.bib> [options]')
	.demandCommand(1)
	.array('omit')
	.describe('omit', tidy.options.omit.description)
	.default('omit', tidy.options.omit.value)
	.boolean('sort')
	.describe('sort', tidy.options.sort.description)
	.default('sort', tidy.options.sort.value)
	.boolean('curly')
	.describe('curly', tidy.options.curly.description)
	.default('curly', tidy.options.curly.value)
	.boolean('numeric')
	.describe('numeric', tidy.options.numeric.description)
	.default('numeric', tidy.options.numeric.value)
	.number('space')
	.describe('space', tidy.options.space.description)
	.default('space', tidy.options.space.value)
	.boolean('tab')
	.describe('tab', tidy.options.tab.description)
	.default('tab', tidy.options.tab.value)
	.boolean('merge')
	.describe('merge', tidy.options.merge.description)
	.default('merge', tidy.options.merge.value)
	.boolean('metadata')
	.describe('metadata', tidy.options.metadata.description)
	.default('metadata', tidy.options.metadata.value)
	.boolean('citations')
	.describe('citations', 'In metadata, count citations within tex files in this directory')
	.default('citations', false)
	.boolean('stats')
	.describe('stats', 'Print statistics about entries')
	.default('stats', false)
	.help('help')
	.argv;
const input = argv._[0];

const readTexInDir = dir => {
	return fs.readdirSync(dir).map(f => {
		const p = `${dir}/${f}`;
		return fs.statSync(p).isDirectory() ? readTexInDir(p) : p.endsWith('.tex') ? fs.readFileSync(p) : '';
	}).join('');
};
const idx = str => str.toLowerCase().replace(/^the /, '');
const alphabetical = (a, b) => idx(a) < idx(b) ? -1 : idx(a) > idx(b) ? 1 : 0;

console.log('Tidying...');

const bibtex = fs.readFileSync(input, 'utf8');
const result = tidy.tidy(bibtex, {
	omit: argv.omit,
	sort: argv.sort,
	curly: argv.curly,
	numeric: argv.numeric,
	space: argv.space,
	tab: argv.tab,
	metadata: argv.metadata,
	citations: argv.citations,
	merge: argv.merge,
	tex: readTexInDir(path.dirname(input))
});

console.log(`Done. Successfully tidied ${result.entries.length} entries.`);
if (argv.citations) {
	console.log(`${result.entries.filter(e => e.citations > 0).length} of which have been cited at least once`);
}
if (argv.merge) {
	console.log(`${result.duplicates.length} merged:`);
	result.duplicates.forEach(dupe => console.log(` ${dupe.entry.id} merged into ${dupe.duplicateOf.id}`));
}
if (argv.stats) {
	console.log('Statistics:');
	[['proceedings', result.proceedings], ['publishers', result.publishers], ['journals', result.journals]].forEach(([key, counts]) => {
		console.log(`${Object.keys(counts).length} ${key}:`);
		Object.keys(counts)
			.sort(alphabetical)
			.forEach(name => console.log(` [${String(counts[name]).padStart(5)}] ${name}`));
	});
}
fs.writeFileSync(`${input}.original`, bibtex, 'utf8');
fs.writeFileSync(input, result.bibtex, 'utf8');
