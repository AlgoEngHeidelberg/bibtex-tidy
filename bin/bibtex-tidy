#!/usr/bin/env node
/* jshint node: true, esversion: 6 */
'use strict';

const tidy = require('../bibtex-tidy.js');
const fs = require('fs');

const options = {};

const unCamelCase = str => str.replace(/[A-Z]/g, c => `-${c.toLowerCase()}`);
const camelCase = str => str.replace(/-[a-z]/g, c => c.charAt(1).toUpperCase());

for (let k of Object.keys(tidy.options)) {
	options[unCamelCase(k)] = {
		description: tidy.options[k].description,
		type: tidy.options[k].type,
		default: tidy.options[k].value
	};
}

const argv = require('yargs')
	.usage('Usage: $0 <file.bib> [options]')
	.demandCommand(1)
	.options(options)
	.boolean('stats')
	.describe('stats', 'Print statistics about entries')
	.default('stats', false)
	.help('help')
	.argv;
const input = argv._[0];

const idx = str => str.toLowerCase().replace(/^the /, '');
const alphabetical = (a, b) => idx(a) < idx(b) ? -1 : idx(a) > idx(b) ? 1 : 0;

console.log('Tidying...');

const bibtex = fs.readFileSync(input, 'utf8');

let opts = {};
for (let k of Object.keys(argv)) {
	opts[camelCase(k)] = argv[k];
}

if (opts.sort && opts.sort.length === 0) { opts.sort = true; }
if (opts.sort && typeof opts.sort[0] === 'boolean') { opts.sort = opts.sort[0]; }
if (opts.sortProperties && opts.sortProperties.length === 0) { opts.sortProperties = true; }
if (opts.sortProperties && typeof opts.sortProperties[0] === 'boolean') { opts.sortProperties = opts.sortProperties[0]; }

const result = tidy.tidy(bibtex, opts);

console.log(`Done. Successfully tidied ${result.entries.length} entries.`);
if (argv.citations) {
	console.log(`${result.entries.filter(e => e.citations > 0).length} of which have been cited at least once`);
}
if (argv.merge) {
	console.log(`${result.duplicates.length} merged:`);
	result.duplicates.forEach(dupe => console.log(` ${dupe.entry.id} merged into ${dupe.duplicateOf.id}`));
}
if (argv.stats) {
	console.log('Statistics:');
	[['proceedings', result.proceedings], ['publishers', result.publishers], ['journals', result.journals]].forEach(([key, counts]) => {
		console.log(`${Object.keys(counts).length} ${key}:`);
		Object.keys(counts)
			.sort(alphabetical)
			.forEach(name => console.log(` [${String(counts[name]).padStart(5)}] ${name}`));
	});
}
fs.writeFileSync(`${input}.original`, bibtex, 'utf8');
fs.writeFileSync(input, result.bibtex, 'utf8');
