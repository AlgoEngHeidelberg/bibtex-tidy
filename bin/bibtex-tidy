#!/usr/bin/env node
/* jshint node: true, esversion: 6 */
'use strict';

const tidy = require('../bibtex-tidy.js');
const fs = require('fs');

const options = {
	help: {
		description: 'Show help',
		type: 'boolean'
	}
};

const ts = require('typescript');

let program = ts.createProgram(['./src/index.ts'], {
	target: ts.ScriptTarget.ES5,
	module: ts.ModuleKind.CommonJS
});

let checker = program.getTypeChecker();

const sourceFile = program
	.getSourceFiles()
	.find(({ path }) => path.endsWith('/src/index.ts'));

ts.forEachChild(sourceFile, node => {
	delete node.parent;
	let symbol = checker.getSymbolAtLocation(node.name);
	if (symbol && symbol.escapedName === 'Options') {
		const members = symbol.declarations[0].type.members;
		members.forEach(member => {
			const key = member.name.escapedText;
			const arg = key.replace(/[A-Z]/g, c => `-${c.toLowerCase()}`); // convert camelCase to --dash-argument
			options[arg] = {
				key,
				description: member.jsDoc[0].comment.replace(/\s+/g, ' '),
				examples: (member.jsDoc[0].tags || []).map(m => m.comment),
				type: checker.typeToString(
					checker.getTypeOfSymbolAtLocation(
						member.symbol,
						member.symbol.valueDeclaration
					)
				)
			};
		});
	}
});

const args = {};
let input;

class NoSuchOption extends Error {}

try {
	let option;
	for (let i = 2; i < process.argv.length; i++) {
		const arg = process.argv[i];
		let [key, val] = arg.split('=');
		if (key.startsWith('--no-')) {
			option = options[key.slice(5)];
			if (!option) throw new NoSuchOption(option);
			args[option.key] = false;
		} else if (key.startsWith('--')) {
			option = options[key.slice(2)];
			if (!option) throw new NoSuchOption(option);
			if (option.type === 'array' && val !== undefined) val = val.split(',');
			if (option.type === 'number' && val !== undefined) val = Number(val);
			args[option.key] = val === undefined ? true : val;
		} else if (option && (i < process.argv.length - 1 || input)) {
			switch (option.type) {
				case 'array':
					key = key.split(',');
					args[option.key] =
						args[option.key] === true ? key : [...args[option.key], ...key];
					break;
				case 'number':
					args[option.key] = Number(key);
					option = null;
					break;
				default:
					args[option.key] = key;
					option = null;
			}
		} else {
			input = arg;
		}
	}
} catch (e) {
	if (e instanceof NoSuchOption) {
		console.error(`No option "${e.message}"`);
		process.exit(1);
	} else throw e;
}

const BREAK_LINE = 84;
const LEFT_MARGIN = 27;

const splitLines = (line, limit) => {
	const words = line.split(' ');
	const lines = [''];
	for (const word of words) {
		if (lines[lines.length - 1].length + word.length + 1 > limit)
			lines.push('');
		lines[lines.length - 1] += word + ' ';
	}
	return lines;
};

if (!input || args.help) {
	console.log(`Usage: bibtex-tidy [OPTION]... FILE.BIB`);
	console.log('BibTeX Tidy - cleaner and formatter for BibTeX files.');
	console.log('Options:');
	for (const [key, opt] of Object.entries(options)) {
		const lines = splitLines(`${opt.description}`, BREAK_LINE - LEFT_MARGIN);
		if (opt.examples) {
			const margin = BREAK_LINE - LEFT_MARGIN;
			const examples = opt.examples.join(' ');
			lines.push(...splitLines(`Examples: ${examples}`, margin));
		}
		for (let i = 0; i < lines.length; i++) {
			let prefix = '';
			if (i === 0) {
				let keyval = key;
				if (opt.type === 'array') keyval += '=x,y,z';
				if (opt.type === 'number') keyval += '=NUMBER';
				prefix = `  --${keyval}`.padEnd(LEFT_MARGIN, ' ');
			} else if (i === 1 && opt.default === true) {
				prefix = `  --no-${key}`.padEnd(LEFT_MARGIN, ' ');
			} else {
				prefix = ' '.repeat(LEFT_MARGIN);
			}
			console.log(prefix + (lines[i] || ''));
		}
		console.log('');
	}
	console.log(
		'Full documentation <https://github.com/FlamingTempura/bibtex-tidy>'
	);
	process.exit(1);
}

console.log('Tidying...');

const bibtex = fs.readFileSync(input, 'utf8');
const result = tidy.tidy(bibtex, args);

for (let warning of result.warnings) {
	console.error(warning.code + ': ' + warning.message);
}

console.log(`Done. Successfully tidied ${result.entries.length} entries.`);
if (args.merge) {
	const dupes = result.warnings.filter(w => w.code === 'DUPLICATE_ENTRY');
	console.log(`${dupes.length} entries merged`);
}
fs.writeFileSync(`${input}.original`, bibtex, 'utf8');
fs.writeFileSync(input, result.bibtex, 'utf8');
